"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$merge = void 0;
var aggregator_1 = require("../../aggregator");
var core_1 = require("../../core");
var util_1 = require("../../util");
var accumulator_1 = require("../accumulator");
/**
 * Writes the resulting documents of the aggregation pipeline to a collection.
 *
 * The stage can incorporate (insert new documents, merge documents, replace documents,
 * keep existing documents, fail the operation, process documents with a custom update pipeline)
 * the results into an output collection. To use the $merge stage, it must be the last stage in the pipeline.
 *
 * Note: Object are deep cloned for outputing regardless of the ProcessingMode.
 *
 * @param collection
 * @param expr
 * @param options
 * @returns {*}
 */
function $merge(collection, expr, options) {
    var output = (0, util_1.isString)(expr.into)
        ? options === null || options === void 0 ? void 0 : options.collectionResolver(expr.into)
        : expr.into;
    (0, util_1.assert)(output instanceof Array, "$merge: option 'into' must resolve to an array");
    var onField = expr.on || options.idKey;
    var getHash = function (o) {
        var val = (0, util_1.isString)(onField)
            ? (0, util_1.resolve)(o, onField)
            : onField.map(function (s) { return (0, util_1.resolve)(o, s); });
        return (0, util_1.hashCode)(val, options.hashFunction);
    };
    var hash = {};
    // we assuming the lookup expressions are unique
    for (var i = 0; i < output.length; i++) {
        var obj = output[i];
        var k = getHash(obj);
        (0, util_1.assert)(!hash[k], "$merge: 'into' collection must have unique entries for the 'on' field.");
        hash[k] = [obj, i];
    }
    return collection.map(function (o) {
        var k = getHash(o);
        if (hash[k]) {
            var _a = hash[k], target = _a[0], i = _a[1];
            if ((0, util_1.isArray)(expr.whenMatched)) {
                var vars = expr.let
                    ? (0, core_1.computeValue)(target, expr.let, null, options)
                    : {};
                var newObj = {};
                try {
                    var aggregator = new aggregator_1.Aggregator(expr.whenMatched, options);
                    target["$new"] = o;
                    for (var _i = 0, _b = Object.entries(vars); _i < _b.length; _i++) {
                        var _c = _b[_i], name_1 = _c[0], val = _c[1];
                        target["$" + name_1] = val;
                    }
                    Object.assign(newObj, aggregator.run([target])[0]);
                }
                finally {
                    delete newObj["$new"];
                    for (var _d = 0, _e = Object.keys(vars); _d < _e.length; _d++) {
                        var name_2 = _e[_d];
                        delete newObj["$" + name_2];
                    }
                }
                output[i] = newObj;
            }
            else {
                switch (expr.whenMatched) {
                    case "replace":
                        output[i] = o;
                        break;
                    case "fail":
                        throw new Error("$merge: failed due to matching as specified by 'whenMatched' option.");
                    case "keepExisting":
                        break;
                    case "merge":
                    default:
                        output[i] = (0, accumulator_1.$mergeObjects)(o, [target, o], options);
                        break;
                }
            }
        }
        else {
            switch (expr.whenNotMatched) {
                case "discard":
                    break;
                case "fail":
                    throw new Error("$merge: failed due to matching as specified by 'whenMatched' option.");
                case "insert":
                default:
                    output.push(o);
                    break;
            }
        }
        return o; // passthrough
    });
}
exports.$merge = $merge;
